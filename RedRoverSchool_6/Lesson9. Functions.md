------------------------------------------- ФУНКЦИИ ------------------------------------------------------

Это именованный фрагмент кода, отделенный от других. Она может принимать любое количество любых входных параметров и возвращать любое количество любых результатов.

Функции это объекты, поэтому их можно присваивать переменным, передавать их в качестве аргуметов и возвращать из других функций

------------------ ВАРИАНТ1 (через print)
```
def multi (a, b):
    print(a * b)

multi(5, 10)
```
> RESULT: 50

---------------- ВАРИАНТ 2 (через return, т.е. возвращение: вернуть результат)

```
def multi (a, b):
    return a * b

print(multi(5, 10))
```
> RESULT: 50

-------------------- ВАРИАНТ 3

```
def multi (a, b):
    return a * b
num = (multi(5, 10)) + 10

print(num)
```
> RESULT: 60

------------------ ВАРИАНТ 4

```
def multi (a, b):
    return a * b
num = multi(5, 10)
num1 = multi(6, 12)

print(num)
print(num1)
```
> RESULT: 50
> 72


```
def calc (a, b):
   print(a)
   print(b)
   return a + b
```

- def calc = название функции
- a, b = переменные (аргументы)

-  print(a)

   print(b)
   
   return a + b
   
это тело функции

return a + b = возвращаемое значение

___________________________________

---------------------------------------- ФУНКЦИИ МОГУТ БЫТЬ КАК ТЕ, которые ПРИНИМАЮТ ПАРАМЕТРЫ и НЕ ПРИНИМАЮТ ПАРАМЕТРЫ --------------------------------------

1. Функции, которые НЕ ПРИНИМАЮТ ПАРАМЕТРЫ 

```
def say_hello():
    print('Hello')

say_hello()
```
> RESULT: Hello

------------------------------ АРГУМЕНТЫ И ПАРАМЕТРЫ ------------------------------------------------------

- ПАРАМЕТР это имя в списке параметров в первой строке определения функции. ОН ПОЛУЧАЕТ СВОЕ ЗНАЧЕНИЕ ПРИ ВЫЗОВЕ

- АРГУМЕНТ это РЕАЛЬНОЕ ЗНАЧЕНИЕ или ссылка на него, переданное функции ПРИ ВЫЗОВЕ (например этой функции):

```
def sum(x, y):
    return x + y
    
print(sum(1,2))
```

x, y ПАРАМЕТРЫ

sum(1,2) АРГУМЕНТЫ

### АРГУМЕНТЫ МОГУТ БЫТЬ:

#### ПОЗИЦИОННЫЕ. Их значения копируются в соответсвующие параметры по порядку

#### ИМЕНОВАННЫЕ. Передаются не просто как значения. А как пара "имя = значение". Поэтому их МОЖНО ПЕРЕДАВАТЬ В ЛЮБОМ ПОРЯДКЕ

Для позиционных нужно соблюдать порядок элементов: 

```
def add_it(a, b, c = 3):
     return a + b + c
     
print(add_it(8, 10, c = 5))
```

8, 10, c = 5 СТРОГО ПО ПОРЯДКУ

```
def person(f_name, last_name, age):
    return f'Hello, my name is {f_name} {last_name}, I am {age} years old'

print(person('Anna', 'Smith', 30))
```

> RESULT: Hello, my name is Anna Smith, I am 30 years old
> Выдало верно, тк указали в подходящем порядке переменные
_________

Для ИМЕНОВАННЫХ можно НЕ СОБЛЮДАТЬ ПОРЯДОК:

```
def add_it(a, b, c = 3):
     return a + b + c
     
print(add_it(b = 8, a  = 10, c = 18))
```

b = 8, a  = 10, c = 18 НЕ ПО ПОРЯДКУ

```
def person(f_name, last_name, age = 20):
    return f'Hello, my name is {f_name} {last_name}, I am {age} years old'

print(person('Anna', 'Smith'))
```

> RESULT: Hello, my name is Anna Smith, I am 20 years old
> Все верно, тк возраст именованный 



-------------------------------------------------------- ВСТРОЕННАЯ ФУНКЦИЯ: 

```
print(sum([5, 6, 8, 12]))
```
> RESULT: 31


```
print(min([5, 6, 8, 12]))
```
> RESULT: 5

```
print(max([5, 6, 8, 12]))
```
> RESULT: 12


-------------------------------------------- АНОНИМНЫЕ ФУНКЦИИ: ЛЯМБДА ВЫРАЖЕНИЯ ----------------------------------------------------------------------

Анонимные функции могут содержать лишь ОДНО выражение + выполняются они БЫСТРЕЕ

Анонимные функции создаются с помощью инструкции **LAMBDA**

Кроме того в отличии от обычной функции их НЕОБЯЗАТЕЛЬНО ПРИСВАИВАТЬ ПЕРЕМЕННОЙ

LAMBDA функции НЕ ТРЕБУЕТСЯ инструкция return

Приименяются лямбда чаще всего для функций ВЫСШЕГО ПОРЯДКА (т.е. функций которые содержат в себе Функции)

> Чаще всего лямбды применяются для встроенных функций filter, map, reduce

Лямбда, вот тебе аргумент и что нужно сделать с этим аргументом. Например тут вот n и возведи это n в квадрат

```
lambda argument: manipulate(argument)
lambda n: n*n
```

```
mult = lambda x, y: x*y
print(mult(5, 6))
```
> RESULT: 30


------------- ОТФИЛЬТРОВАТЬ СПИСОК С ПОМОЩЬЮ lambda функции для получения только ЧЕТНЫХ ЗНАЧЕНИЙ

```
l = [20, 'str', 15, 18, 'yes', 'apple', 48, 40.5]
filters = list(filter(lambda x: isinstance(x, int) and x % 2 == 0, l))
print(filters)
```
> RESULT: [20, 18, 48]


Для нечетных значений: 4

```
l = [20, 'str', 15, 18, 'yes', 'apple', 48, 40.5]
filters = list(filter(lambda x: isinstance(x, int) and x % 2, l))
print(filters)
```
> RESULT: [15]

Для вывода БЕЗ квадратных скобок:

```
l = [20, 'str', 15, 18, 'yes', 'apple', 48, 40.5]
filters = list(filter(lambda x: isinstance(x, int) and x % 2, l))
print(*filters)
```
> RESULT: 15


Вывод ОДНОВРЕМЕННО и ЦЕЛЫХ ЧИСЕЛ и ФЛОАТ

```
l = [20, 'str', 15, 18, 'yes', 'apple', 48, 40.5]
filters = list(filter(lambda x: isinstance(x, int) or isinstance(x, float), l))
print(*filters)
```
> RESULT: 20 15 18 48 40.5


```
def calc (a, b=1):
    print(a*b)

result = calc(5, 9)
print(f'Result: {result}')
```
> RESULT: 
> 45
> Result: None


```
def calc (a, b=1):
    return a*b

result = calc(5, 9)
print(f'Result: {result}')
```
> Result: Result: 45


---------------- лямбда с функцией map (функция map применит условие которое мы зададим к какждому индексы списка)!!!!

```
l1 = [20, 15, 8, 7, 6]
power = list(map(lambda x: x**2, l1))
print(power)
```
> RESULT: [400, 225, 64, 49, 36]


-------------------------------- Функция reduce = Приведет все к ОДНОМУ РЕЗУЛЬТАТУ (который мы укажем)

```
l1 = [20, 15, 8, 7, 6]
from functools import reduce
result = reduce(lambda x,y: x - y, l1)
print(result)
```
> RESULT: -16 тк  20 - 15 - 8 - 7 - 6 = -16


