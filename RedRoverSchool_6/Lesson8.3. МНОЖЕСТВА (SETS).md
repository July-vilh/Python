1) МНОЖЕСТВА ЭТО КАК СЛОВАРИ, ЕДИНСТВЕННОЕ В СЕТАХ ЕСТЬ ТОЛЬКО КЛЮЧИ, А ЗНАЧЕНИЯ ВЫБРОШЕНЫ
2) ЗНАЧЕНИЯ ВО МНОЖЕСТВАХ НЕ ДОЛЖНЫ ПОВТОРЯТЬСЯ 

-------------------------------- СОЗДАНИЕ МНОЖЕСТВ -----------------------------------------
1) ПЕРЕЧИСЛЕНИЕ ЭЛЕМЕНТОВ В ФИГУРНЫХ СКОБКАХ 

```
my_set = {'A', 'B', 'C'}
print(my_set)
```
> RESULT: {'A', 'C', 'B'}

2) С ПОМОЩЬЮ ФУНКЦИИ SET()

```
my_set = set{}
```

----------------------------------- МНОЖЕСТВА УДОБНО ПРИМЕНЯТЬ ДЛЯ УДАЛЕНИЯ ПОВТОРЯЮЩИХСЯ ЭЛЕМЕНТОВ С ПЕРЕВОДОМ В СЕТ: 

```
my_list = [1, 8, 2, 1, 5, 8, 9]
print(set(my_list))
```
> RESULT: {1, 2, 5, 8, 9}

------------------------------- ПРОВЕРКА НА СРАВНЕНИЕ (НАПРИМЕР ПОХОЖ ЛИ СЕТ2 НА СЕТ1 (Т.Е. ЯВЛЯЕТСЯ ЛИ СЕТ2 ПОДМНОЖЕСТВОМ СЕТ1)

```
set_1 = {1, 2, 3, 'one', 'ten', 6}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.issubset(set_2))
```

> RESULT: False

```
set_1 = {1, 2, 3, 'one', 'ten'}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
print(set_1.issubset(set_2))
```
> RESULT: True
> ТЕПЕРЬ ТУТ СЕТ_1 БЕЗ 6 ЯВЛЯЕТСЯ ПОДМНОЖЕСТВОМ (ЧАСТЬЮ) СЕТ_2

--------------------------- ПРОВЕРКА ЧТО СЕТ2 ВКЛЮЧАЕТ В СЕБЯ СЕТ1

```
set_1 = {1, 2, 3, 'one', 'ten'}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
print(set_2.issuperset(set_1))
```

> RESULT: True

--------------------------- ПРОВЕРКА ЧТО СЕТ2 ВКЛЮЧАЕТ В СЕБЯ СЕТ1

```
set_1 = {1, 2, 3, 'one', 'ten'}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.issuperset(set_2))
```

> RESULT: False (тк сет2 теперь не полностью включает в себя сет1)

-------------------------------- Метод для проверки СОВПАДЕНИЙ intersection

```
set_1 = {1, 2, 3, 'one', 'ten'}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_2.intersection(set_1))
```

> RESULT: {1, 2, 3, 'one', 'ten'}

------------------------- Напечатать значение сет2 которое отличается от сета1 (МЕТОД disserence)

```
set_1 = {1, 2, 3, 'one', 'ten'}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_2.difference(set_1))
```

> RESULT: {25, 100, 500}

```
set_1 = {1, 2, 3, 'one', 'ten', 20}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.difference(set_2))
```
> RESULT: {20}

------------------- Выевести значений которые НЕ ПОВТОРЯЮТСЯ НИ ТАМ НИ ЗДЕСЬ

```
set_1 = {1, 2, 3, 'one', 'ten', 20}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.symmetric_difference(set_2))
```
> RESULT: {100, 500, 20, 25}

--------------------- Удаление составляющего из сета (метод REMOVE) по конкретному названию составляющего (НЕ ПО ИНДЕКСУ)

```
set_1 = {1, 2, 3, 'one', 'ten', 20}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.remove('one'))
print(set_1)
```
> RESULT: {1, 2, 3, 20, 'ten'}

-------------------------- ДОБАВЛЕНИЕ НОВОГО ЗНАЧЕНИЯ (после удаления)

```
set_1 = {1, 2, 3, 'one', 'ten', 20}
set_2 = {1, 2, 3, 'one', 'ten', 100, 500, 25}
set_3 = {1, 2, 3}

print(set_1.add(56))
print(set_1)
```

> RESULT: {1, 2, 3, 'ten', 20, 56}

----------------------- Метод frozenset (для ЗАМОРОЗКИ сета)

```
fs = frozenset({1, 2, 3})
print (fs)
```

> RESULT: frozenset({1, 2, 3})

После этого получается по сути с fs ничего толком не сделаешь (ни remove, ни add)

------------------- МЕТОД len(s) = РАЗМЕР МНОЖЕСТВА

-------------------- X in S = Принадлежит ли X множеству S

------------------- SET.POP = Удаляет ПЕРВЫЙ элемент из множества

------------------- SET.CLEAR() = ОЧИСТКА множества

